



/*bitand_assign
&=

bitor_assign
|=

bitxor_assign
^=

div
/

div_assign
/=

rem_assign
%=

mul
Performs the * operation

mul_assign
*=

shl_assign
<<=

shl_assign
<<=

shr_assign
>>=

sub_assign
-=*/

mask
The mask element type corresponding to this element type
type Mask = i8



Performs the conversion.
impl<T> From<T> for T

pub fn from(t: T) -> T
Performs the conversion.

impl<T, U> Into<U> for T
where
    U: From<T>, 
[src]
pub fn into(self) -> U


into
Performs the conversion.
impl<T, U> Into<U> for T
where
    U: From<T>, 
[src]
pub fn into(self) -> U

```
impl<'_, '_> Shl<&'_ u32> for &'_ u8
type Output = <u8 as Shl<u32>>::Output
The resulting type after applying the << operator.
```
```
impl Shl<u32> for u8
type Output = u8
The resulting type after applying the << operator.
```

Hasher
A trait for hashing an arbitrary stream of bytes.
Instances of Hasher usually represent state that is changed while hashing data.
Hasher provides a fairly basic interface for retrieving the generated hash (with finish), and writing integers as well as slices of bytes into an instance (with write and write_u8 etc.). Most of the time, Hasher instances are used in conjunction with the Hash trait.
This trait makes no assumptions about how the various write_* methods are defined and implementations of Hash should not assume that they work one way or another. You cannot assume, for example, that a write_u32 call is equivalent to four calls of write_u8.
```
use std::collections::hash_map::DefaultHasher;
use std::hash::Hasher;

let mut hasher = DefaultHasher::new();

hasher.write_u32(1989);
hasher.write_u8(11);
hasher.write_u8(9);
hasher.write(b"Huh?");

println!("Hash is {:x}!", hasher.finish());
```

hash
hash<H>(&self, state: &mut H)
Feeds this value into the given Hasher.

hash_slice
hash_slice<H>(data: &[u8], state: &mut H)
Feeds a slice of this type into the given Hasher.

fn write_u8(&mut self, i: u8)
Writes a single u8 into this hasher.

```
use std::collections::hash_map::DefaultHasher;
use std::hash::Hasher;

let mut hasher = DefaultHasher::new();
let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];
hasher.write(&data);
println!("Hash is {:x}!", hasher.finish());
```

finish(&self) -> u64
Returns the hash value for the values written so far.
Despite its name, the method does not reset the hasher’s internal state. Additional writes will continue from the current value. If you need to start a fresh hash value, you will have to create a new hasher.
```
use std::collections::hash_map::DefaultHasher;
use std::hash::Hasher;
let mut hasher = DefaultHasher::new();
hasher.write(b"Cool!");
println!("Hash is {:x}!", hasher.finish());
```


    /////////////////////
    // // log2
    // //Returns the base 2 logarithm of the number, rounded down.
    // #![feature(int_log)]
    // assert_eq!(2u8.log2(), 1);

    // // log10
    // // Returns the base 10 logarithm of the number, rounded down.
    // #![feature(int_log)]
    // assert_eq!(10u8.log10(), 1);


    // // Saturating integer addition.
    // // Computes self + rhs, saturating at the numeric bounds instead of overflowing.
    // assert_eq!(100u8.saturating_add(1), 101);
    // assert_eq!(u8::MAX.saturating_add(127), u8::MAX);

    // // Saturating integer subtraction. 
    // // Computes self - rhs, saturating at the numeric bounds instead of overflowing.
    // assert_eq!(100u8.saturating_sub(27), 73);
    // assert_eq!(13u8.saturating_sub(127), 0);



u8::MIN
Returns the smallest value that can be represented by this integer type.
u8::MIN

u8::MAX 
Returns the largest value that can be represented by this integer type.
u8::MAX

widening_mul
Calculates the complete product self * rhs without the possibility to overflow.
This returns the low-order (wrapping) bits and the high-order (overflow) bits of the result as two separate values, in that order.
#![feature(bigint_helper_methods)]
assert_eq!(5u32.widening_mul(2), (10, 0));
assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));

carrying_mul
Calculates the “full multiplication” self * rhs + carry without the possibility to overflow.
This returns the low-order (wrapping) bits and the high-order (overflow) bits of the result as two separate values, in that order.
Performs “long multiplication” which takes in an extra amount to add, and may return an additional amount of overflow. This allows for chaining together multiple multiplications to create “big integers” which represent larger values.
#![feature(bigint_helper_methods)]
assert_eq!(5u32.carrying_mul(2, 0), (10, 0));
assert_eq!(5u32.carrying_mul(2, 10), (20, 0));
assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));
assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));
assert_eq!(u8::MAX.carrying_mul(u8::MAX, u8::MAX), (0, u8::MAX));

forward
Returns the value that would be obtained by taking the successor of self count times.
forward(start: u8, n: usize) -> u8

backward
Returns the value that would be obtained by taking the predecessor of self count times.
backward(start: u8, n: usize) -> u8

steps_between(start: &u8, end: &u8) -> Option<usize>
Returns the number of successor steps required to get from start to end.

sum<I>(iter: I) -> u8
Method which takes an iterator and generates Self from the elements by “summing up” the items.
